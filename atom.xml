<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一口田的独立博客</title>
  
  <subtitle>爱生活，爱编码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tsxf.github.io/"/>
  <updated>2017-10-21T09:08:21.018Z</updated>
  <id>https://tsxf.github.io/</id>
  
  <author>
    <name>tsxf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quartz简明使用指南</title>
    <link href="https://tsxf.github.io/2017/10/21/use-quartz/"/>
    <id>https://tsxf.github.io/2017/10/21/use-quartz/</id>
    <published>2017-10-21T06:13:35.000Z</published>
    <updated>2017-10-21T09:08:21.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>&emsp;在开发中经常会遇到需要定时运行的任务或者需要重复进行的任务，jdk提供了一个Timer可以完成这样的任务，但是Timer不能处理并发任务，因为一个Timer同一时刻只能运行一个任务；也不能处理类似Linux里面的cron任务，更为重要的是如果遇到了异常没有捕获到或者任务阻塞，Timer就会挂掉，任务就得不到执行。现在推荐使用Quartz来做这样的事情。<br><a id="more"></a><br>&emsp;Quartz任务默认是无状态，例如我们定义一个 trigger，每 2 分钟执行一次，但是某些情况下一个任务可能需要 3 分钟才能执行完，这样，在上一个任务还处在执行状态时，下一次触发时间已经到了。对于无状态任务，只要触发时间到了就会被执行，因为几个相同任务可以并发执行。</p><p>&emsp;作为一个优秀的开源调度框架，Quartz 具有以下特点：</p><ol><li>强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求</li><li>灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</li><li>分布式和集群能力</li></ol><p>&emsp;另外，作为 Spring 默认的调度框架，Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。</p><h2 id="Quartz体系结构"><a href="#Quartz体系结构" class="headerlink" title="Quartz体系结构"></a>Quartz体系结构</h2><p>scheduler：任务调度器</p><p>trigger：触发器，用于定义任务调度时间规则</p><p>job：任务，即被调度的任务</p><p>misfire：错过的，指本来应该被执行但实际没有被执行的任务调度</p><h2 id="Quartz-任务调度的基本实现原理"><a href="#Quartz-任务调度的基本实现原理" class="headerlink" title="Quartz 任务调度的基本实现原理"></a>Quartz 任务调度的基本实现原理</h2><p><strong>核心元素</strong></p><p>&emsp;Quartz任务调度的核心元素是scheduler,trigger和job，其中trigger和job是任务调度的元数据， scheduler是实际执行调度的控制器。</p><p>&emsp;在Quartz中，trigger是用于定义调度时间的元素，即按照什么时间规则去执行任务。Quartz中主要提供了四种类型的trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，和 NthIncludedDayTrigger。</p><p>&emsp;在Quartz中，job用于表示被调度的任务。主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。对于同一个 trigger 来说，有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。Job 主要有两种属性：volatility 和 durability，其中 volatility 表示任务是否被持久化到数据库存储，而 durability 表示在没有 trigger 关联的时候任务是否被保留。两者都是在值为 true 的时候任务被持久化或保留。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job。</p><p>&emsp;在Quartz中，scheduler由scheduler工厂创建：DirectSchedulerFactory 或者 StdSchedulerFactory。第二种工厂StdSchedulerFactory使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。Scheduler主要有三种：RemoteMBeanScheduler， RemoteScheduler和StdScheduler。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>定义Job业务类，实现Job接口</strong></p><pre><code>package com.test.quartz;import java.util.Date;import org.quartz.DisallowConcurrentExecution;import org.quartz.Job;import org.quartz.JobDetail;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class HelloQuartz implements Job { public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail detail = context.getJobDetail(); String name = detail.getJobDataMap().getString(&quot;name&quot;); System.out.println(&quot;say hello to &quot; + name + &quot; at &quot; + new Date());   }}</code></pre><p><strong>测试Job</strong></p><pre><code>package com.test.quartz;import static org.quartz.DateBuilder.newDate;import static org.quartz.JobBuilder.newJob;import static org.quartz.SimpleScheduleBuilder.simpleSchedule;import static org.quartz.TriggerBuilder.newTrigger;import java.util.GregorianCalendar;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.Trigger;import org.quartz.impl.StdSchedulerFactory;import org.quartz.impl.calendar.AnnualCalendar;public class QuartzTest {public static void main(String[] args) {try {//创建schedulerScheduler scheduler = StdSchedulerFactory.getDefaultScheduler();//定义一个TriggerTrigger trigger = newTrigger().withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) //定义name/group.startNow()//一旦加入scheduler，立即生效.withSchedule(simpleSchedule() //使用SimpleTrigger.withIntervalInSeconds(1) //每隔一秒执行一次.repeatForever()) //一直执行，奔腾到老不停歇.build();//定义一个JobDetailJobDetail job = newJob(HelloQuartz.class) //定义Job类为HelloQuartz类，这是真正的执行逻辑所在.withIdentity(&quot;job1&quot;, &quot;group1&quot;) //定义name/group.usingJobData(&quot;name&quot;, &quot;quartz&quot;) //定义属性.build();//加入这个调度scheduler.scheduleJob(job, trigger);//启动之scheduler.start();//运行一段时间后关闭Thread.sleep(10000);scheduler.shutdown(true);} catch (Exception e) {e.printStackTrace();}}}</code></pre><p>&emsp;常用的触发 Trigger用SimpleTrigger和CronTirgger就足够了</p><p>&emsp;CronTrigger例子</p><pre><code>// 通过schedulerFactory获取一个调度器   SchedulerFactory schedulerfactory = new StdSchedulerFactory();   try {       // 通过schedulerFactory获取一个调度器       scheduler = schedulerfactory.getScheduler();       // 创建jobDetail实例，绑定Job实现类       // 指明job的名称，所在组的名称，以及绑定job类       JobDetail job = JobBuilder.newJob(CtrlRoomQuartz.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).build();       // 定义调度触发规则       // corn表达式 每taskSeconds秒执行一次       Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;CronTrigger1&quot;, &quot;CronTriggerGroup&quot;)               .withSchedule(CronScheduleBuilder.cronSchedule(&quot;*/&quot; + taskSeconds + &quot;  * * * * ?&quot;)).startNow()               .build();       // 把作业和触发器注册到任务调度中       scheduler.scheduleJob(job, trigger);       // 启动调度       scheduler.start();   } catch (SchedulerException e) {       e.printStackTrace();   }</code></pre><p>&ensp;向业务里面传递参数，有两种方式，Trigger和JobDetail都可以传参数。</p><p>&ensp;第一种用usingJobData，JobDetail里面有一个JobDataMap可以放一些参数信息，JobDataMap实现了JDK的Map接口</p><pre><code>// 创建jobDetail实例，绑定Job实现类// 指明job的名称，所在组的名称，以及绑定job类JobDetail job = JobBuilder.newJob(PoliceQuartz.class)        .withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;).usingJobData(&quot;EXTEND_POSITION&quot;, EXTEND_POSITION)        .usingJobData(&quot;SEGMENTAT_WORD&quot;, SEGMENTAT_WORD).usingJobData(&quot;prefix&quot;, prefix)        .usingJobData(&quot;hotelId&quot;, hotelId).usingJobData(&quot;defaultTimeoutSecond&quot;, defaultTimeoutSecond)        .usingJobData(&quot;dataTimeoutSecond&quot;, dataTimeoutSecond)        .usingJobData(&quot;connectTimeoutSecond&quot;, connectTimeoutSecond)        .build();</code></pre><p>&ensp;第二种通过JobDetail对象获取JobDataMap,put一些参数，在业务里面需要实现对应放的key的set方法，Quartz会在每次通过反射创建Job对象之后，调用set方法把参数放进去，在业务里面可以直接使用参数，或者想前面例子中的在excunte()方法中通过context上下文拿到jobDetail对象，再通过jobDetail对象deJobDataMap中通过Map的key获取值。</p><pre><code>// 创建jobDetail实例，绑定Job实现类// 指明job的名称，所在组的名称，以及绑定job类JobDetail job = JobBuilder.newJob(VodJob.class).withIdentity(&quot;JobName&quot;, &quot;JobGroupName&quot;)        .usingJobData(&quot;hotelId&quot;, hotelId).usingJobData(&quot;wsdlAddress&quot;, wsdlAddress)        .usingJobData(&quot;empno&quot;, empno).usingJobData(&quot;boolPurchase&quot;, boolPurchase).build();//作业任务参数传递job.getJobDataMap().put(&quot;hotelId&quot;, hotelId);job.getJobDataMap().put(&quot;wsdlAddress&quot;, wsdlAddress);job.getJobDataMap().put(&quot;empno&quot;, empno);job.getJobDataMap().put(&quot;boolPurchase&quot;, boolPurchase);job.getJobDataMap().put(&quot;ft&quot;, ft);job.getJobDataMap().put(&quot;factory&quot;, factory);job.getJobDataMap().put(&quot;facadeBase&quot;, facadeBase);job.getJobDataMap().put(&quot;client&quot;, client);</code></pre><p>&ensp;Job里面实现参数的set方法</p><pre><code>public void setHotelId(String hotelId) {    this.hotelId = hotelId;}public void setFacadeBase(JPQLFacadeBase facadeBase) {    this.facadeBase = facadeBase;}public void setClient(TvbzWsApi4PmsServicePortType client) {    this.client = client;}public void setWsdlAddress(String wsdlAddress) {    this.wsdlAddress = wsdlAddress;}public void setFactory(TvbzWsApi4PmsService factory) {    this.factory = factory;}public void setFt(FoxItfVodBiz ft) {    this.ft = ft;}public void setEmpno(String empno) {    this.empno = empno;}public void setBoolPurchase(boolean boolPurchase) {    this.boolPurchase = boolPurchase;}</code></pre><p>&ensp;<strong>Cron表达式详解</strong></p><p>CronTrigger 支持比 SimpleTrigger 更具体的调度，而且也不是很复杂。基于 cron 表达式，CronTrigger 支持类似日历的重复间隔，而不是单一的时间间隔 —— 这相对 SimpleTrigger 而言是一大改进。<br>Cron 表达式包括以下 7 个字段：</p><ul><li>秒   &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp;            0-59      &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;    , - * /</li><li>分  &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp;     0-59 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; , - * /</li><li>小时&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp; 0-23    &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;, - * /</li><li>月内日期 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;1-31 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;  , - * ? / L W C</li><li>月&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp; &ensp;&ensp; &ensp;&ensp;&ensp;   1-12&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;, - * /</li><li>周内日期&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;&ensp;&ensp;&ensp;1-7&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;, - * ? / L C #    </li><li>年（可选字段）&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1-31&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;, - * /</li></ul><p>星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如， 在分钟字段时，表示“每分钟”；</p><p>问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；</p><p>减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；</p><p>逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；</p><p>斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；</p><p>L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示星期六，等同于7。但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五；</p><p>W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围；</p><p>LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；</p><p>井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；</p><p>C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</p><p>Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</p><p><strong>如果觉得编写Cron表达式比较麻烦或者不知道写的表达式正确与否，可以通过Cron在线测试工具测试自己写的表达式。</strong></p><p>一些例子：</p><p>表示式    说明</p><p>0 0 12 <em> </em> ?    每天12点运行</p><p>0 15 10 ? <em> </em>    每天10:15运行</p><p>0 15 10 <em> </em> ?    每天10:15运行</p><p>0 15 10 <em> </em> ? *    每天10:15运行</p><p>0 15 10 <em> </em> ? 2008    在2008年的每天10：15运行</p><p>0 <em> 14 </em> * ?    每天14点到15点之间每分钟运行一次，开始于14:00，结束于14:59。</p><p>0 0/5 14 <em> </em> ?    每天14点到15点每5分钟运行一次，开始于14:00，结束于14:55。</p><p>0 0/5 14,18 <em> </em> ?    每天14点到15点每5分钟运行一次，此外每天18点到19点每5钟也运行一次。</p><p>0 0-5 14 <em> </em> ?    每天14:00点到14:05，每分钟运行一次。</p><p>0 10,44 14 ? 3 WED    3月每周三的14:10分到14:44，每分钟运行一次。</p><p>0 15 10 ? * MON-FRI    每周一，二，三，四，五的10:15分运行。</p><p>0 15 10 15 * ?    每月15日10:15分运行。</p><p>0 15 10 L * ?    每月最后一天10:15分运行。</p><p>0 15 10 ? * 6L    每月最后一个星期五10:15分运行。</p><p>0 15 10 ? * 6L 2007-2009    在2007,2008,2009年每个月的最后一个星期五的10:15分运行。</p><p>0 15 10 ? * 6#3    每月第三个星期五的10:15分运行。</p><p>参考文章：</p><p>  <a href="http://www.cnblogs.com/drift-ice/p/3817269.html" target="_blank" rel="external">Quartz使用总结（超详细）</a></p><p>  <a href="https://nkcoder.github.io/2014/06/22/quartz-tutorial-quickstart/" target="_blank" rel="external">Quartz教程–快速入门（官网中文翻译） </a></p><p> <a href="https://www.ibm.com/developerworks/cn/java/j-quartz/index.html" target="_blank" rel="external">用 Quartz 进行作业调度 </a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/" target="_blank" rel="external">基于 Quartz 开发企业级任务调度应用 </a></p><p><a href="http://www.imooc.com/learn/846" target="_blank" rel="external">Java定时任务调度工具详解之Quartz篇（慕课视频） </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简要说明&quot;&gt;&lt;a href=&quot;#简要说明&quot; class=&quot;headerlink&quot; title=&quot;简要说明&quot;&gt;&lt;/a&gt;简要说明&lt;/h2&gt;&lt;p&gt;&amp;emsp;在开发中经常会遇到需要定时运行的任务或者需要重复进行的任务，jdk提供了一个Timer可以完成这样的任务，但是Timer不能处理并发任务，因为一个Timer同一时刻只能运行一个任务；也不能处理类似Linux里面的cron任务，更为重要的是如果遇到了异常没有捕获到或者任务阻塞，Timer就会挂掉，任务就得不到执行。现在推荐使用Quartz来做这样的事情。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="https://tsxf.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="https://tsxf.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>java中的代理模式</title>
    <link href="https://tsxf.github.io/2017/10/13/proxy/"/>
    <id>https://tsxf.github.io/2017/10/13/proxy/</id>
    <published>2017-10-13T09:05:10.000Z</published>
    <updated>2017-10-13T12:26:39.992Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <h2 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h2><ol><li>静态代理</li><li>动态代理</li></ol><p>&emsp;静态代理代码在编译期间就有了，也就是事先写好了代理代码。动态代理，在编译期间没有生成，在程序运行中生成的代理类。JDK的动态代理要求必须是接口。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>&emsp;静态代理模式其实很常见，比如买火车票这件小事：黄牛相当于是火车站的代理，我们可以通过黄牛买票，但只能去火车站进行改签和退票。在代码实现中相当于为一个委托对象realSubject提供一个代理对象proxy，通过proxy可以调用realSubject的部分功能，并添加一些额外的业务处理，同时可以屏蔽realSubject中未开放的接口。</p><p><img src="https://i.imgur.com/rbQuu8N.png" alt=""></p><p>1、RealSubject是委托类，Proxy是代理类</p><p>2、Subject是委托类和代理类的接口</p><p>3、request()是委托类和代理类中的共同方法</p><p>代码实现如下：</p><pre><code>interface Subject { void request();}class RealSubject implements Subject {    public void request(){    System.out.println(&quot;RealSubject&quot;);  }}class Proxy implements Subject {    private Subject subject;public Proxy(Subject subject){        this.subject = subject;  }public void request(){        System.out.println(&quot;begin&quot;);     subject.request();        System.out.println(&quot;end&quot;);  }}public class ProxyTest {    public static void main(String args[]) {            RealSubject subject = new RealSubject();            Proxy p = new Proxy(subject);            p.request();  }}</code></pre><p>&emsp;静态代理实现中，一个委托类对应一个代理类，代理类在编译期间就已经确定了。</p><p>&emsp;可以看到在代理类Proxy中持有一个委托类RealSubject的引用，并且代理类和委托类都实现了相同的Subject接口，在调用委托类RealSubject的request()方法时，实际上是调用代理类的request()方法，我们可以在代理类相同的方法中做一些处理，比如：访问控制，日志输出等。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>&emsp;动态代理中，代理类并不是在Java代码中实现，而是在运行时期生成，相比静态代理，动态代理可以很方便的对委托类的方法进行统一处理，如添加方法调用次数、添加日志功能等等，动态代理分为jdk动态代理和cglib动态代理，下面通过一个例子看看如何实现jdk动态代理</p><p>&emsp; 定义Helloworld接口（Suubject）</p><pre><code>package proxy;public interface Helloworld {    void sayHello();    void sayHi();}</code></pre><p>&emsp; 定义HelloworldImpl实现Helloworld接口（RealSubject）</p><pre><code> package proxy;public class HelloworldImpl implements Helloworld {    @Override    public void sayHello() {        System.out.println(&quot;hello world&quot;);    }    @Override    public void sayHi() {        System.out.println(&quot;say hi&quot;);    }}</code></pre><p>  &emsp; 定义MyInvocationHandler实现InvocationHandler接口（Proxy）  </p><pre><code>package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler {    private Object target;    public MyInvocationHandler(Object target) {        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;method :&quot; + method.getName() + &quot; is invoked!&quot;);        return method.invoke(target, args);    }}</code></pre><p>  &emsp; 定义测试类JDKProxyTest</p><pre><code> package proxy;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;/** * JDKProxy 代理demo程序 * 必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。 * @author Soul * */public class JDKProxyTest {    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException {        // 这里有两种写法        // 第一种        // 拿到要代理对象的字节码Class        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Helloworld.class.getClassLoader(), Helloworld.class);//JDKProxyTest        // 通过给字节码的构造器Constructor指定参数传值，构造出构造器对象        final Constructor&lt;?&gt; cons = proxyClass.getConstructor(InvocationHandler.class);        // 需要增强的功能，入参为原来的接口功能        final InvocationHandler ih = new MyInvocationHandler(new HelloworldImpl());        // 通过newInstance生成代理对象,加载到内存中        Helloworld helloWorld = (Helloworld) cons.newInstance(ih);        // 调用代理对象的sayHello()方法        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用        helloWorld.sayHello();        helloWorld.sayHi();        // 下面是更简单的一种写法，本质上和上面是一样的        /*HelloWorld helloWorld = (HelloWorld) Proxy.newProxyInstance(JDKProxyTest.class.getClassLoader(),                new Class&lt;?&gt;[] { HelloWorld.class }, new MyInvocationHandler(new HelloworldImpl()));        helloWorld.sayHello();*/    }}</code></pre><p>&emsp;可以在Eclipse中JRE中缺省参数加入-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true 这个参数加入到JVM 启动参数中，它的作用是帮我们把JDK动态生成的proxy class 的字节码保存到硬盘中，帮助我们查看具体生成proxy的内容。</p><p>&emsp;程序运行结果:</p><pre><code>method :sayHello is invoked!hello worldmethod :sayHi is invoked!say hi</code></pre><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>代理类生成的过程主要包括两部分：</p><p><code>*</code>代理类字节码生成</p><p><code>*</code>把字节码通过传入的类加载器加载到虚拟机中</p><p>Proxy类的getProxyClass方法入口：需要传入类加载器和interface</p><p><img src="https://i.imgur.com/CRRGaNi.png" alt=""><br>然后调用getProxyClass0方法，里面的注解解释很清楚，如果实现当前接口的代理类存在，直接从缓存中返回，如果不存在，则通过ProxyClassFactory来创建。这里可以明显看到有对interface接口数量的限制，不能超过65535。其中proxyClassCache具体初始化信息如下：</p><p>proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());<br>其中创建代理类的具体逻辑是通过ProxyClassFactory的apply方法来创建的。<br><img src="https://i.imgur.com/p1L8OJ5.png" alt=""></p><p>proxyClassCache内容信息<br><img src="https://i.imgur.com/LxenOyo.png" alt=""></p><p>ProxyClassFactory里的逻辑包括了包名的创建逻辑，调用ProxyGenerator. generateProxyClass生成代理类，把代理类字节码加载到JVM。</p><ol><li><p>包名生成逻辑默认是com.sun.proxy，如果被代理类是 non-public proxy interface ，则用和被代理类接口一样的包名，类名默认是$Proxy 加上一个自增的整数值。</p></li><li><p>包名类名准备好后，就是通过ProxyGenerator. generateProxyClass根据具体传入的接口创建代理字节码，-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true 这个参数就是在该方法起到作用，如果为true则保存字节码到磁盘。代理类中，所有的代理方法逻辑都一样都是调用invocationHander的invoke方法，这个我们可以看后面具体代理反编译结果。</p></li><li>把字节码通过传入的类加载器加载到JVM中: defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);。</li></ol><p>ProxyClassFactory代码如下：</p><pre><code> /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */private static final class ProxyClassFactory    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;{    // prefix for all proxy class names    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;    // next number to use for generation of unique proxy class names    private static final AtomicLong nextUniqueNumber = new AtomicLong();    @Override    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);        for (Class&lt;?&gt; intf : interfaces) {            /*             * Verify that the class loader resolves the name of this             * interface to the same Class object.             * 入参 interfaces 检验，包含三部分             * （1）是否在入参指定的 ClassLoader 内             * （2）是否是 Interface             * （3）interfaces 中是否有重复             */            Class&lt;?&gt; interfaceClass = null;            try {                interfaceClass = Class.forName(intf.getName(), false, loader);            } catch (ClassNotFoundException e) {            }            if (interfaceClass != intf) {                throw new IllegalArgumentException(                    intf + &quot; is not visible from class loader&quot;);            }            /*             * Verify that the Class object actually represents an             * interface.             *              */            if (!interfaceClass.isInterface()) {                throw new IllegalArgumentException(                    interfaceClass.getName() + &quot; is not an interface&quot;);            }            /*             * Verify that this interface is not a duplicate.             */            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {                throw new IllegalArgumentException(                    &quot;repeated interface: &quot; + interfaceClass.getName());            }        }        String proxyPkg = null;     // package to define proxy class in        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;        /*         * Record the package of a non-public proxy interface so that the         * proxy class will be defined in the same package.  Verify that         * all non-public proxy interfaces are in the same package.         * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面         */        //生成包名和类名逻辑        for (Class&lt;?&gt; intf : interfaces) {            int flags = intf.getModifiers();            if (!Modifier.isPublic(flags)) {                accessFlags = Modifier.FINAL;                String name = intf.getName();                int n = name.lastIndexOf(&apos;.&apos;);                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                if (proxyPkg == null) {                    proxyPkg = pkg;                } else if (!pkg.equals(proxyPkg)) {                    throw new IllegalArgumentException(                        &quot;non-public interfaces from different packages&quot;);                }            }        }        if (proxyPkg == null) {            // if no non-public proxy interfaces, use com.sun.proxy package            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;        }        /*         * Choose a name for the proxy class to generate.         * 得到代理类的类名         */        long num = nextUniqueNumber.getAndIncrement();        String proxyName = proxyPkg + proxyClassNamePrefix + num;        /*         * Generate the specified proxy class.         * 动态生成代理类的字节码          * -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true 在该部起作用         */        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(            proxyName, interfaces, accessFlags);        try {            //加载到JVM中  native 层实现，虚拟机加载代理类并返回其类对象            return defineClass0(loader, proxyName,                                proxyClassFile, 0, proxyClassFile.length);        } catch (ClassFormatError e) {            /*             * A ClassFormatError here means that (barring bugs in the             * proxy class generation code) there was some other             * invalid aspect of the arguments supplied to the proxy             * class creation (such as virtual machine limitations             * exceeded).             */            throw new IllegalArgumentException(e.toString());        }    }} </code></pre><hr><p>&emsp;我们可以根据代理类的字节码进行反编译，可以得到如下结果，其中HelloWorld有sayHello(),sayHi()方法，但是代理类中有五个方法 包括了Object上的三个方法：equals,toString,hashCode。</p><p>&emsp;代理类是以$Proxy为类名前缀，继承自Proxy，并且实现了Proxy.newProxyInstance(…)第二个参数传入的所有接口的类。<br>如果代理类实现的接口中存在非 public 接口，则其包名为该接口的包名，否则为com.sun.proxy。<br>其中的sayHello()、sayHi()函数都是直接交给h去处理，h在父类Proxy中定义为<br>protected InvocationHandler h;<br>即为Proxy.newProxyInstance(…)第三个参数。<br>所以InvocationHandler的子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。</p><p>&emsp;代理的大概结构包括4部分：</p><p><code>*</code>静态字段：被代理的接口所有方法都有一个对应的静态方法变量；</p><p><code>*</code>静态块：主要是通过反射初始化静态方法变量；</p><p><code>*</code> 具体每个代理方法：逻辑都差不多就是 h.invoke，主要是调用我们定义好的invocatinoHandler逻辑,触发目标对象target上对应的方法;</p><p><code>*</code>构造函数：从这里传入我们InvocationHandler逻辑；</p><p>用jade查看生成的字节码文件</p><pre><code>package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Helloworld;public final class $Proxy0  extends Proxy  implements Helloworld{  private static Method m1;  private static Method m3;  private static Method m4;  private static Method m2;  private static Method m0;  public $Proxy0(InvocationHandler paramInvocationHandler)  {super(paramInvocationHandler);  }  public final boolean equals(Object paramObject)  {try{  return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();}catch (Error|RuntimeException localError){  throw localError;}catch (Throwable localThrowable){  throw new UndeclaredThrowableException(localThrowable);}  }  public final void sayHello()  {try{  this.h.invoke(this, m3, null);  return;}catch (Error|RuntimeException localError){  throw localError;}catch (Throwable localThrowable){  throw new UndeclaredThrowableException(localThrowable);}  }  public final void sayHi()  {try{  this.h.invoke(this, m4, null);  return;}catch (Error|RuntimeException localError){  throw localError;}catch (Throwable localThrowable){  throw new UndeclaredThrowableException(localThrowable);}  }  public final String toString()  {try{  return (String)this.h.invoke(this, m2, null);}catch (Error|RuntimeException localError){  throw localError;}catch (Throwable localThrowable){  throw new UndeclaredThrowableException(localThrowable);}  }  public final int hashCode()  {try{  return ((Integer)this.h.invoke(this, m0, null)).intValue();}catch (Error|RuntimeException localError){  throw localError;}catch (Throwable localThrowable){  throw new UndeclaredThrowableException(localThrowable);}  }  static  {try{  m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) });  m3 = Class.forName(&quot;proxy.Helloworld&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);  m4 = Class.forName(&quot;proxy.Helloworld&quot;).getMethod(&quot;sayHi&quot;, new Class[0]);  m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);  m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);  return;}catch (NoSuchMethodException localNoSuchMethodException){  throw new NoSuchMethodError(localNoSuchMethodException.getMessage());}catch (ClassNotFoundException localClassNotFoundException){  throw new NoClassDefFoundError(localClassNotFoundException.getMessage());}  }}</code></pre><p>&emsp; 我们从上面的字节码可以得出如下结论：   </p><p><strong>1. toString() hashCode() equal()方法 调用逻辑：这个三个Object上的方法，如果被调用将和其他接口方法方法处理逻辑一样，都会经过invocationHandler逻辑，从上面的字节码结果就可以明显看出。其他Object上的方法将不会走代理处理逻辑，直接走Proxy继承的Object上方法逻辑。</strong></p><p><strong>2. interface 含有equals,toString hashCode方法时，和处理普通接口方法一样，都会走invocation handler逻辑，以目标对象重写的逻辑为准去触发方法逻辑；</strong></p><p><strong>3. interface含有重复的方法签名,以接口传入顺序为准，谁在前面就用谁的方法，代理类中只会保留一个，不会有重复的方法签名；</strong></p><p>参考文章：</p><p>  <a href="https://mp.weixin.qq.com/s/cTJ_IankiFOdwZZLq3mHQA" target="_blank" rel="external">Java帝国之动态代理</a></p><p>  <a href="http://www.importnew.com/23168.html" target="_blank" rel="external">JDK动态代理详解 </a></p><p> <a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253d" target="_blank" rel="external">公共技术点之 Java 动态代理 </a></p><p><a href="http://www.importnew.com/23972.html" target="_blank" rel="external">Java核心技术点之动态代理 </a></p><p><a href="http://www.importnew.com/26116.html" target="_blank" rel="external">说说 JAVA 代理模式 </a></p><p><a href="http://www.jianshu.com/p/a1d094fc6c00" target="_blank" rel="external">说说 JAVA 代理模式 </a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;h2 id=&quot;代理的分类&quot;&gt;&lt;a href=&quot;#代理的分类&quot; class=&quot;headerlink&quot; title=&quot;代理的分类&quot;&gt;&lt;/a&gt;代理的分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;静态代理&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ol&gt;
&lt;p
      
    
    </summary>
    
      <category term="blog" scheme="https://tsxf.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="https://tsxf.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>IO流需要掌握的技能栈</title>
    <link href="https://tsxf.github.io/2017/09/22/my-new-post/"/>
    <id>https://tsxf.github.io/2017/09/22/my-new-post/</id>
    <published>2017-09-22T06:13:42.000Z</published>
    <updated>2017-10-13T13:42:15.622Z</updated>
    
    <content type="html"><![CDATA[<ol><li>IO NIO</li><li>网络编程基本概念：TCP/IP协议，IP地址，网关</li><li>TCP编程：Socket概念，TCP连接，UDP编程，TCP服务器多线程模型</li><li>Email编程：SMTP协议，发送邮件，发送附件，嵌入附件，POP3协议，接收邮件</li><li>Http客户端编程：HTTP协议，URLConnection</li><li>RMI远程调用：Java RMI原理＋示例</li><li>WebService  </li></ol><a id="more"></a>  <p>&ensp;&ensp; 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：<a href="http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。" target="_blank" rel="external">http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</a></p><p>&emsp;如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，则请将您的" target="_blank" rel="external">http://yoursite.com/blog，则请将您的</a> url 设为 <a href="http://yoursite.comblog" target="_blank" rel="external">http://yoursite.comblog</a> 并把 root 设为 /blog/。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;IO NIO&lt;/li&gt;
&lt;li&gt;网络编程基本概念：TCP/IP协议，IP地址，网关&lt;/li&gt;
&lt;li&gt;TCP编程：Socket概念，TCP连接，UDP编程，TCP服务器多线程模型&lt;/li&gt;
&lt;li&gt;Email编程：SMTP协议，发送邮件，发送附件，嵌入附件，POP3协议，接收邮件&lt;/li&gt;
&lt;li&gt;Http客户端编程：HTTP协议，URLConnection&lt;/li&gt;
&lt;li&gt;RMI远程调用：Java RMI原理＋示例&lt;/li&gt;
&lt;li&gt;WebService  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="blog" scheme="https://tsxf.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="https://tsxf.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
